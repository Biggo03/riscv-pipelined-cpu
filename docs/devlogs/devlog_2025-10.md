# October

## October. 4th

### Notes:
Today was primarily focused on establishing comprehensive project documentation.
I created a structured set of documents under the `docs/` directory covering all high-level topics related to the processor’s design and supporting infrastructure. This includes a central `README` outlining the purpose of each document and subdirectory, as well as a new `roadmap.md` file defining near- and long-term development priorities. The roadmap is intended to formalize my direction for the project and reduce sprawl, which became an issue over the past month.

The focus was on defining high-level documents that describe major design areas, along with spreadsheet files for organizing key control signal and instruction information. These will be crucial for maintaining consistency and supporting future expansion. The block-level documents remain as placeholders for now and will be populated as the design matures.
The overall goal for the documentation structure is to balance stability and extensibility — central documents should only require occasional updates, while detailed leaf documents can evolve alongside the hardware.

### Summary:
- Created a complete set of high-level project documents.
- Added a roadmap to define project direction and prevent sprawl.
- Introduced spreadsheets for control signal and instruction organization.
- Added skeletons for block-level documentation to be filled progressively.

## October. 6th

### Notes:
Today I began looking at what would be needed to implement the CSR instructions I have planned to add. Of course there's the design of the CSR register, but I also need to determine how it will interact with the rest of the design. Ideally, I want to add the least amount of signals and hardware possible.

I will go over the functionality required for each planned instruction, and my initial plan in implementing said functionality:
    - csrrw: atomic read/write CSR
        - This instruction reads the value of the CSR, and writes that value to **rd**. The source registers value (**rs1**) is then written to the CSR register. This will require:
            - Reading from the CSR reg file (don't need to worry about sign extnesion for now, all registers are XLEN bits (32-bits))
            - Writing the read value from the CSR to the destination register
            - Writing the read value from the standard reg value to the CSR register
    - csrrs: atomic read and set bits in CSR:
        - This instruction reads the value of a CSR, and writes it to **rd**. The value of **rs1** is treated as a bit mask for setting bits in the CSR. This will additionally require:
            - Effectively ORing the CSR reg value, and the value read from **rs1**. This is because this instruction specifies that unmasked bits (bits set to 0 in **rs1**) are to be unaffected, and all other bits are to be set.
            - No additonal functionality in addition to the previous instruction is needed.
    - csrrc: atomic read and clear bits in CSR
        - Reads the value of a CSR and writes it to **rd**. The value of **rs1** os treated as a bit mask for clearing bits in the CSR.
        - This should not require any additional functionality that the previous instructions don't also require
    - csrrwi, csrrsi, csrrci:
        - Same as their non-i counterparts, but done with an immediate encoded in the rs1 field, rather than the register value stored in rs1.
        - The value in the CSR register is still written to the destination registr (**rd**)

To summarize, the additions needed to support these new instructions are as follows:
    - Be able to read from and write to both **rs1** and the **CSR** in the same cycle
    - Perform ALU operation on the data read from the **CSR**, and the data read from **rs1**
    - Perform ALU operations on the data read from the **CSR**, and an immediate
    - Extend immediates encoded in the rs1 field
    - Route the values read from the **CSR** and **rs1** back to the standard register file, and the CSR

I believe to implement these features, the main architectural changes are:
    - Routing values read from the **CSR** and **rs1** to the writeback stage
    - An additional multiplexer in the writeback stage to determine what value is to be written to the CSR
    - Multiplexers within the decode stage to determine what values are sent to the execution stage
    - A CSR register file
    - Control signal to accomodate new multiplexers, new multiplexer inputs, and to control the CSR reg file behaviour
        - Includes neccesary changes to main decoder
    - Additional option within extension unit to handle extending immediates encoded in the rs1 field appropriately.

I believe these architectural changes should allow for execution of these instructions. The first step in developing this will be creation of the CSR register file

In addition to this, I also changed the name of the rd1 and rd2 signals to reg_data_1 and reg_data_2. This is becuase rd also stands for the destination register field, which reduced clarity.

### Summary:
- Scoped out changes needed for implementation of CSR's
- Changed signal name

## October. 7th

### Notes:
I began looking into how I wanted to implement the CSR register file in more depth. At this point, I already have a bare bones implementation that I created a week or two ago when I first looked into adding CSR's, so I used this as a starting point.

The first thing I did was update it to allow for a unique read and write address, and then I allowed for forwarding data, which is essentially just passing the wdata signal to the read output when the read and write addresses match. With that implemented, the file now has macros for each implemented CSR, and should have the basic functionality (although untested).

That said, after looking at this, I thought it may be a good idea to use a script to maintain this file. I'm already planning on using an excel sheet to organize everything related to my CSR registers, so parsing that using a script to generate an otherwise extermely long and repetitive module seems like a good way to go to ensure that the module remains extensible.

I haven't begun work on this script, this was just something I thought of while looking over my old module. With the amount of CSR's I currently have implemented, it definitely isn't neccesary, but it is something I'm interested in doing, and it will absolutely future proof the module, so I think it's worth getting into.

This script would need a template file, or some other way to handle the functionality that's required, and it would also need a way to deal with registers that are updated on a per-cycle basis, like mcycle and minstret. My initial though is to have a module that deals with these functions seperately, and have the relevent values linked to the appropriate registers within the register itself.

All of this will be expanded upon further in the very near future.

While thinking about scripting, I thought it would be good to update my script directory strucure, so I did just that. While doing so, I saw that identical file lists were being made for each risc-v program being run when, so I updated run_regression.py (now test_driver.py) to only generate one file list for integration, or "system" level tests.

### Summary:
- Initial update to csr_regfile module
- Looked into script to maintain csr_regfile
- Updated script directory
- Updated run_regression.py (now test_driver.py) script

## October 8th - 12th

### Notes:
Over the past few days, my main focus was on designing and testing the CSR register file module. I saw this as a good opportunity to explore automatic RTL generation, and decided to also extend that to the testbench for consistency and scalability.

To handle this, I wrote a Python script that parses my csr_spec.xlsx spreadsheet, converts it into a YAML file, and then uses that YAML as the source for code generation. I believe the intermediate YAML will be quite useful — it gives me a clear record of what the spreadsheet contained at the time of generation, and provides an easy reference for debugging or comparing future revisions. Essentially, it’s a simple way to keep a text-based version of what’s stored in the Excel sheet.

For the actual code generation, I used Jinja2 templates. Jinja lets me embed Python-like syntax directly into text files, which makes it easy to loop over registers, insert variable data, and gate behavior based on fields like read/write permissions defined in the spreadsheet. I created two templates — one for the RTL module, and one for the testbench. Within these, I defined logic blocks for different register types. Writable registers, for instance, have next-state logic that handles write-throughs, while special-purpose registers like mcycle and minstret have manually defined logic to handle incrementing each cycle.

This templating approach worked really well — I can now define the behavior for a class of registers once, and have it replicated automatically for every register of that type. Adding new CSRs is as simple as updating the Excel sheet; the script takes care of regenerating the RTL, testbench, and all related files. Only registers with unique behavior require manual additions.

In addition to generating the RTL and testbench, I also added automatic macro generation to the flow. Since this was a simpler task, I didn’t use Jinja here — instead, I handled it directly in Python using basic string operations and file writes. The script iterates over the YAML data and emits a macro header file containing all the \define` statements for CSR names and their addresses. This keeps all definitions consistent across the design, preventing errors that could come from manually syncing addresses between the RTL and testbench.

Overall, this automation framework makes the CSR subsystem much more maintainable and extensible. If/when there are any future additions, it wills ave time, keep the design consistent, and makes it easy to grow the CSR list in the future without manually editing multiple files.

## October 13th

### Notes:
Today I began exploring the addition of the CSR register file and CSR instruction handling in greater detail.
During this process, I decided it would be best to include a small dedicated computational block in the EX stage to perform CSR operations.
The main motivation for this is to ensure that the critical path is not extended.
Since the current critical path already passes through the ALU, integrating CSR logic directly into that path would add unnecessary risk of timing degradation.

This separate computational block also simplifies the overall logic.
CSR data will be routed to the unit after passing through a forwarding multiplexer, allowing RAW hazards to be resolved correctly.
The result from this unit will then propagate through the MEM and WB stages to be written back to rd.
On the input side, data from rs1 and the zero-extended immediate will be selected through an additional multiplexer before entering the CSR unit.

This approach introduces two additional multiplexers, avoids adding delay to the existing critical path,
and keeps the microarchitectural complexity low while maintaining clear dataflow organization.

While reviewing the schematic, I also noticed that both the ghr and local_predictor modules had inferred unintended latches.
This increased both area and potential timing risk.
The issue was caused by incomplete assignment in combinational logic, and was resolved by assigning default values before the conditional next-state logic.
I also added a default case statement for good style, though it should never be triggered under normal operation.

### Summary:
- Determined implementation strategy for CSR register file/instructions
- Fixed un-intended latches in the design

## October 20th - 25th

### Notes:
Over these days, I continued to work on the csr addition. I implemented and tested my "csr_alu" unit, which deals with all csr operations, and finalized my plan for implementing
the CSR related modules into the datapath. This included making the neccesary changes to the extension unit, creating the csr_decider module, and updating the main decoder to output
the csr_we signal.

In addition to this, I reworked my test-driving setup to be much more clear and easily extensible. This included a full rework of the test_list.yml file (now "test_catalog.yml",
as well as updates to the command line arguments. Now you can pass regressions, individual tests, and macros directly to the test driver, making it much clearer what is going on.
The python script was updated to accomodate this setup, and while doing this, I made it more robust, and modular in places I thought would be useful (for example, run cmd generation
is now its own function). Overall the test driver is now cleaner, more modular, and more customizable.

While updating the test driver, I added a number of flags to the simulation in order to get more verbose information in my logs. After doing this, and running a couple tests, I found
some issues with my RTl code. The main one being that I didn't actually pass stall_e_i to my branch_prediction_unit. This likely reduced branch prediction effeciency in all previous runs,
but did not affect correctness of running programs. The other one is that stall_w, and stall_m were not declared in the pipelined_riscv module. They were implicitly defined as they were
used at module boundries, but this is of course not good for clarity, so that was fixed.

Additionally, I made some updates to the main_mem_model, these were mostly related to best practices and style, nothing functional was changed

### Summary:
- Created and tested csr_alu and csr_decoder modules
- Reworked test driving setup
- Small RTL fixes and cleanup
