# November

## November 1st - 6th

### Notes
Over these days, I completed the implementation of csr functionality. This included routing the csr_data directly through the pipeline so that it could be used for forwarding,
and writing back to the standard register file, forwarding the neccesary signals back for the csr_alu, and fixing any bugs introduced or found during this implementation.

Once everything was routed as needed, and the current system smoke test passed, I created the csr testing program. This program was a number of sections, each with their own set of csr instructions.
each of these sections finished with a branch to a label that would write a failure value to the success flag memory location. In this way, the assembly program only passes if the
operation in each section pass.

To do this, it was easiest to not use the implemented cycle counters to test the instructions, as their values would be harder to pin down and verify. Becase of this, the mstatus register
was added to essentially act as a test register in this case.

During testing, a very important bug was also found in the instruction cache controller. It was found that the delay guard FSM was exiting the DELAYING state improperly.
The cause of this was that the state change condition was: (**~**instr_hit_f_o | pc_src_reg_i[0]) rather than (instr_hit_f_o | pc_src_reg_i[0]). This caused the fsm to improperly
oscillate states when a cache miss and branch hit/miss occured in the same cycle.

Essentially, the condition to switch only when there is a hit, is to ensure that all data is in place before allowing the pipeline to contiue operating. When the
condition is flipped, the cache effectively exits replacement while the replacement data continues to fill in. This leave the block only partially filled, meaning that
a "cache hit" can not occur, stalling the system indefinitely.

This issue was likely caused when I changed the instr_miss signl to instr_hit, missing that inversion.

This reveals that my testing for cache integration and coherency were not extensive, and means that I will likely revisit this to ensure that all edge cases are properly handelled.

In additon to this, I made small QOL improvements to my test driver. These include the option to list all available tests, as well as the use of the ordered set type to ensure that
regressions always run tests in the order listed within the test catalog.

### Summary
- Completed implementation functionality needed for csr instructions
- Tested CSR instrucion operation
- Added mstatus csr
- Fixed instruction cache controller bug
- QOL improvements for test driver

## November 8th

### Notes:
Today I focused on updating the documentation to reflect the current state of design, and reworking my standard test pass condition. I won't delve into the documentation, but I will give an overview of the standard test pass condition

Previously. the test pass condition was writing the decimal value 25 to the decimal memory location 100. This was a little clunky, and I could see it causing issues later on for more tests, as it didn't really make sense considering my memory map. So I decided to make use of my new csr functionality, and created a custom csr, mtest_status. This register will essentially act as the pass fail flag. When ABCD1234 is written it is seen as a pass, when DEADBEEF is written, it is seen as a fail.

I believe this is more robust, configurable, extensible and easier to monitor. Rather than writing an arbitrary value to an arbitrary memory location, the location (register), and value now have a distinct meaning. I can add new values with new meanings easily across both the hardware, and software portions of the design, or add new CSR's to hold new information.

While doing this, I added assembly macros, and C inline functions to write the pass and fail values to the register of interest to make inserting the pass/fail condition in software tests easy. In addition, I wrote basic inline functions to write values to any generic CSR register.

I also began automatically generating a C header file with all CSR addresses, which will allow for easy CSR access whenever software is being written for the processor.

### Summary:
- Consolidated documentation
- Updated test pass condition
- Created CSR read and write functions for C code
- Created test pass macros for assembly
- Automatically generate C header file containing csr addresses
